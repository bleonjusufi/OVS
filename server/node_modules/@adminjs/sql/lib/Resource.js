import { BaseRecord, BaseResource, } from 'adminjs';
import { ResourceMetadata } from './metadata/index.js';
export class Resource extends BaseResource {
    static isAdapterFor(resource) {
        const r = resource instanceof ResourceMetadata;
        if (!r) {
            throw new Error('Resource must contain valid metadata.');
        }
        return r;
    }
    knex;
    propertyMap = new Map();
    tableName;
    schemaName = 'public';
    _database;
    _properties;
    idColumn;
    constructor(info) {
        super(info.tableName);
        this.knex = info.knex;
        this.schemaName = info.schemaName;
        this.tableName = info.tableName;
        this._database = info.database;
        this._properties = info.properties;
        this._properties.forEach((p) => {
            this.propertyMap.set(p.path(), p);
        });
        this.idColumn = info.idProperty.path();
    }
    databaseName() {
        return this._database;
    }
    // eslint-disable-next-line class-methods-use-this
    databaseType() {
        return 'Postgres';
    }
    id() {
        return this.tableName;
    }
    properties() {
        return this._properties;
    }
    property(path) {
        return this.propertyMap.get(path) ?? null;
    }
    async count(filter) {
        const [r] = await this.filterQuery(filter).count('* as cnt');
        return r.cnt;
    }
    async find(filter, options) {
        const query = this.filterQuery(filter);
        if (options.limit) {
            query.limit(options.limit);
        }
        if (options.offset) {
            query.offset(options.offset);
        }
        if (options.sort?.sortBy) {
            query.orderBy(options.sort.sortBy, options.sort.direction);
        }
        const rows = await query;
        return rows.map((row) => new BaseRecord(row, this));
    }
    async findOne(id) {
        const res = await this.knex(this.tableName).withSchema(this.schemaName).where(this.idColumn, id);
        return res[0] ? this.build(res[0]) : null;
    }
    async findMany(ids) {
        const res = await this.knex(this.tableName).withSchema(this.schemaName).whereIn(this.idColumn, ids);
        return res.map((r) => this.build(r));
    }
    build(params) {
        return new BaseRecord(params, this);
    }
    async create(params) {
        await this.knex(this.tableName).withSchema(this.schemaName).insert(params);
        return params;
    }
    async update(id, params) {
        await this.knex
            .from(this.tableName)
            .update(params)
            .where(this.idColumn, id);
        const [row] = await this.knex(this.tableName).withSchema(this.schemaName).where(this.idColumn, id);
        return row;
    }
    async delete(id) {
        await this.knex.withSchema(this.schemaName).from(this.tableName).delete().where(this.idColumn, id);
    }
    filterQuery(filter) {
        const q = this.knex(this.tableName).withSchema(this.schemaName);
        if (!filter) {
            return q;
        }
        const { filters } = filter;
        Object.entries(filters ?? {}).forEach(([key, filter]) => {
            if (typeof filter.value === 'object') {
                q.whereBetween(key, [filter.value.from, filter.value.to]);
            }
            else {
                q.where(key, filter.value);
            }
        });
        return q;
    }
}
//# sourceMappingURL=Resource.js.map